#include "node.h"
#include "node_version.h"
#include "nan.h"
#include <string>

#include "uv.h"
#include "v8.h"
#include "v8-profiler.h"
#include "v8-testing.h"
#include <bzlib.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <assert.h>
#include "Vector.h"
#include "list.h"

#include "../src/api.h"
#include "../src/serialize.h"
#include "../src/natives.h"
#include "../src/bootstrapper.h"
#include "../lib/json/json.h"

using namespace v8;
using namespace node;

// For some reason this needs to be out of the object or node won't load the
// library.
static Persistent<FunctionTemplate> dataWrapperTmpl;
static Persistent<Function>         dataWrapperCtor;

/*
    * Adapted from Godmar's hook.c.
 */
static void hexdump(void *buf, size_t len)
{
        size_t i, j;
        char *b = (char *)buf;

        printf(".---------------------------------------------------------------------------.\n");
        for (i = 0; i < len; i += 16) {
                printf("| %08lx      ", i);
                for (j = i; j < i+16; j++) {
                        if (j % 4 == 0)
                                printf(" ");
                        if (j >= len)
                                printf("  ");
                        else
                                printf("%02x", (unsigned char)b[j]);
                }

                printf("       ");
                for (j = i; j < i+16; j++)
                        if (j >= len)
                                printf(" ");
                        else
                                printf("%c", isgraph(b[j]) ? b[j] : '.');
                printf(" |\n");
        }
        printf("`---------------------------------------------------------------------------'\n");
}

class Compressor {
 public:
  virtual ~Compressor() {}
  virtual bool Compress(i::Vector<char> input) = 0;
  virtual i::Vector<char>* output() = 0;
};

class PartialSnapshotSink : public i::SnapshotByteSink {
 public:
  PartialSnapshotSink() : data_(), raw_size_(-1) { }
  virtual ~PartialSnapshotSink() { data_.Free(); }
  virtual void Put(int byte, const char* description) {
    data_.Add(byte);
  }
  virtual int Position() { return data_.length(); }
  void Print(FILE* fp) {
    int length = Position();
    for (int j = 0; j < length; j++) {
      if ((j & 0x1f) == 0x1f) {
        fprintf(fp, "\n");
      }
      if (j != 0) {
        fprintf(fp, ",");
      }
      fprintf(fp, "%u", static_cast<unsigned char>(at(j)));

    }
  }

  void PrintMyVersion(FILE* fp_)
  {
    int length = Position();
    unsigned char contextData[length];
    for (int j = 0; j < length; j++) {
      contextData[j] = static_cast<unsigned char>(at(j));
    }
    fwrite(contextData, length, 1, fp_);
  }

  /*
  unsigned char* getData() {
    int length = Position();
    unsigned char data_local[length];
    for (int j = 0; j < length; j++) {
      data_local[j] = static_cast<unsigned char>(at(j));
    }
    return data_local;
  }
  */

  char at(int i) { return data_[i]; }
  bool Compress(Compressor* compressor) {
    ASSERT_EQ(-1, raw_size_);
    raw_size_ = data_.length();
    if (!compressor->Compress(data_.ToVector())) return false;
    data_.Clear();
    data_.AddAll(*compressor->output());
    return true;
  }
  int raw_size() { return raw_size_; }

 private:
  i::List<char> data_;
  int raw_size_;
};

class myByteSink : public PartialSnapshotSink {
 public:
  explicit myByteSink(const char* snapshot_file) {
    fp_ = i::OS::FOpen(snapshot_file, "wb");
    if (fp_ == NULL) {
      i::PrintF("Unable to write to snapshot file \"%s\"\n", snapshot_file);
      exit(1);
    }
    //fprintf(fp_, "\"Snapshot_data\" : [");

  }

  virtual ~myByteSink() {
    /*
    fprintf(fp_, "\"Snapshot_size\" : %d , \n", Position());
    fprintf(fp_, "\"Snapshot_raw_data\" : NULL ,\n");
    fprintf(fp_, "\"raw_size\" : %d \n", raw_size());
    fprintf(fp_, "} \n");
    */
    fclose(fp_);
  }

void WriteSpaceUsed(
      const char* prefix,
      uint32_t new_space_used,
      uint32_t pointer_space_used,
      uint32_t data_space_used,
      uint32_t code_space_used,
      uint32_t map_space_used,
      uint32_t cell_space_used) {
    cout << "while wrirting context new space used: "<< new_space_used<<"\n";
    cout << "while wrirting context pointer space used: "<< pointer_space_used<<"\n";
    cout << "while wrirting context data space used: "<< data_space_used<<"\n";
    cout << "while wrirting context code space used: "<< code_space_used<<"\n";
    cout << "while wrirting context map space used: "<< map_space_used<<"\n";
    cout << "while wrirting context cell space used: "<< cell_space_used<<"\n";

    fwrite(&new_space_used, sizeof(new_space_used), 1, fp_);
    fwrite(&pointer_space_used, sizeof(pointer_space_used), 1, fp_);
    fwrite(&data_space_used, sizeof(data_space_used), 1, fp_);
    fwrite(&code_space_used, sizeof(code_space_used), 1, fp_);
    fwrite(&map_space_used, sizeof(map_space_used), 1, fp_);
    fwrite(&cell_space_used, sizeof(cell_space_used), 1, fp_);
/*
    fprintf(fp_, "\"%snew_space_used\" :  %d ,\n", prefix, new_space_used);
    fprintf(fp_, "\"%spointer_space_used\" : %d ,\n", prefix, pointer_space_used);
    fprintf(fp_, "\"%sdata_space_used\" : %d ,\n", prefix, data_space_used);
    fprintf(fp_, "\"%scode_space_used\" : %d, \n", prefix, code_space_used);
    fprintf(fp_, "\"%smap_space_used\" : %d ,\n", prefix, map_space_used);
    fprintf(fp_, "\"%scell_space_used\" : %d ,\n", prefix, cell_space_used);
*/
  }

  void WritePartialSnapshot() {

    uint32_t context_size = partial_sink_.Position();
    fwrite(&context_size, sizeof(context_size), 1, fp_);

    uint32_t context_raw_size = partial_sink_.raw_size();
    fwrite(&context_raw_size, sizeof(context_raw_size), 1, fp_);

    cout << "before context data"; 
    cout << "\n"; 
    cout << "context size:" << context_size<<"\n";
    
    partial_sink_.PrintMyVersion(fp_);

    //hexdump(contextData, context_size);

    
    /*
    int length = partial_sink_.Position();
    fprintf(fp_, "],\n");
    fprintf(fp_, "\"Context_size\" : %d ,\n",  length);
    fprintf(fp_, "\"context_raw_size\" : %d ,\n", partial_sink_.raw_size());
    fprintf(fp_, "\"context_data\" : [\n");
    partial_sink_.Print(fp_);
    fprintf(fp_, "],\n");
    fprintf(fp_, "\"context_raw_data\" : NULL ,\n");
    */
  }

  void WriteSnapshot() {
    Print(fp_);
  }

  PartialSnapshotSink* partial_sink() { return &partial_sink_; }

 private:
  FILE* fp_;
  PartialSnapshotSink partial_sink_;
};


class BZip2Compressor : public Compressor {
 public:
  BZip2Compressor() : output_(NULL) {}
  virtual ~BZip2Compressor() {
    delete output_;
  }
  virtual bool Compress(i::Vector<char> input) {
    delete output_;
    output_ = new i::ScopedVector<char>((input.length() * 101) / 100 + 1000);
    unsigned int output_length_ = output_->length();
    int result = BZ2_bzBuffToBuffCompress(output_->start(), &output_length_,
                                          input.start(), input.length(),
                                          9, 1, 0);
    if (result == BZ_OK) {
      output_->Truncate(output_length_);
      return true;
    } else {
      fprintf(stderr, "bzlib error code: %d\n", result);
      return false;
    }
  }
  virtual i::Vector<char>* output() { return output_; }

 private:
  i::ScopedVector<char>* output_;
};


class BZip2Decompressor : public StartupDataDecompressor {
 public:
  virtual ~BZip2Decompressor() { }

 protected:
  virtual int DecompressData(char* raw_data,
                             int* raw_data_size,
                             const char* compressed_data,
                             int compressed_data_size) {
    ASSERT_EQ(StartupData::kBZip2,
              V8::GetCompressedStartupDataAlgorithm());
    unsigned int decompressed_size = *raw_data_size;
    int result =
        BZ2_bzBuffToBuffDecompress(raw_data,
                                   &decompressed_size,
                                   const_cast<char*>(compressed_data),
                                   compressed_data_size,
                                   0, 1);
    if (result == BZ_OK) {
      *raw_data_size = decompressed_size;
    }
    return result;
  }
};

class restoreContextFromSnapshot{

    private:
        uint32_t context_new_space_used_;
        uint32_t context_pointer_space_used_;
        uint32_t context_data_space_used_;
        uint32_t context_code_space_used_;
        uint32_t context_map_space_used_;
        uint32_t context_cell_space_used_;
        /*uint32_t new_space_used_;
        uint32_t pointer_space_used_;
        uint32_t data_space_used_;
        uint32_t code_space_used_;
        uint32_t map_space_used_;
        uint32_t cell_space_used_;
        *///byte data_[];
        //v8::Handle<v8::Object> data_;
        //v8::Handle<v8::Object> context_data_;
        //i::byte *raw_data_;
        //byte context_data_[];
        unsigned char *context_raw_data_;
        //uint32_t size_;
        //uint32_t raw_size_;
        uint32_t context_size_;
        uint32_t context_raw_size_;
        //uint32_t Snapshot_size;
    

    public:
        restoreContextFromSnapshot(int t)
        {
            /*
            Json::Value root;   // will contains the root value after parsing.
            Json::Reader reader;
            bool parsingSuccessful = reader.parse( "../myNewSnap.json", root );
            if ( !parsingSuccessful )
            {
                // report to the user the failure and their locations in the document.
                std::cout  << "Failed to parse configuration\n"
                            << reader.getFormattedErrorMessages();
            }
            */

            //data_ = v8::Object::New();
            //data_ -> SetIndexedPropertiesToExternalArrayData(ptr, v8::kExternalByteArray, 1024);
            /*
            Json::Value snapshot_data = root["Snapshot_data"];
            for ( int index = 0; index < snapshot_data.size(); ++index )  // Iterates over the sequence elements.
                intData_ = snapshot_data[index].asInt();

            raw_data_ = reinterpret_cast<i::byte*> (intData_);
            */

            //raw_data_ = reinterpret_cast<i::byte*>(root.get("Snapshot_data", 0).asInt());

            //context_size_ = root.get("Context_size", 0 ).asInt();
            //context_raw_size_ = root.get("context_raw_size", 0 ).asInt();

            /*
            Json::Value context_data = root["context_data"];
            for ( int index = 0; index < context_data.size(); ++index )  // Iterates over the sequence elements.
                context_raw_data_ = context_data[index].asInt();
            */
            /*
            context_raw_data_ = reinterpret_cast<i::byte*>(root.get("context_data", 0).asInt());

            context_new_space_used_ = root.get("context_new_space_used", 0).asInt();
            context_pointer_space_used_ = root.get("context_pointer_space_used", 0 ).asInt();
            context_data_space_used_ = root.get("context_data_space_used", 0 ).asInt();
            context_code_space_used_ = root.get("context_code_space_used", 0).asInt();
            context_map_space_used_ = root.get("context_map_space_used", 0 ).asInt();
            context_cell_space_used_ = root.get("context_cell_space_used", 0 ).asInt();
            new_space_used_ = root.get("new_space_used", 0).asInt();
            pointer_space_used_ = root.get("pointer_space_used", 0).asInt();
            data_space_used_ = root.get("data_space_used", 0 ).asInt();
            code_space_used_ = root.get("code_space_used", 0).asInt();
            map_space_used_ = root.get("map_space_used", 0).asInt();
            cell_space_used_ = root.get("cell_space_used", 0 ).asInt();
            Snapshot_size = root.get("Snapshot_size", 0 ).asInt();
            raw_size_ = root.get("raw_size", 0 ).asInt();
            
            context_raw_size_ = 162981;
            context_new_space_used_ = 0;
            context_pointer_space_used_ = 354896;
            context_data_space_used_ = 1752;
            context_code_space_used_ = 0;
            context_map_space_used_ = 79616;
            context_cell_space_used_ = 16832;

            */

            FILE *file = NULL;
            if((file = fopen("/myHome/Courses/CS 6204 Cloud Environments/Project/code/snapshotContextLoader/node_modules/contextify/myBinarySnap", "rb")) == NULL)
                cout << "File Failed To Load\n";
            else
                cout << "File Loaded Successfully\n";
            
            /*
            long prev=ftell(file);
            fseek(file, 0L, SEEK_END);
            long fileSize =ftell(file);
            fseek(file,prev,SEEK_SET);
            */
            
            fread(&context_size_, sizeof(context_size_), 1, file);
            fread(&context_raw_size_, sizeof(context_raw_size_), 1, file);  
            cout << "context size : " <<context_size_ <<"\n" ;
            context_raw_data_ = new unsigned char[context_size_];
            fread(context_raw_data_, context_size_, 1, file);  
            cout << "context read Successfully" << "\n";
            fread(&context_new_space_used_, sizeof(context_new_space_used_), 1, file);
            fread(&context_pointer_space_used_, sizeof(context_pointer_space_used_), 1, file);
            fread(&context_data_space_used_, sizeof(context_data_space_used_), 1, file);
            fread(&context_code_space_used_, sizeof(context_code_space_used_), 1, file);
            fread(&context_map_space_used_, sizeof(context_map_space_used_), 1, file);
            fread(&context_cell_space_used_, sizeof(context_cell_space_used_), 1, file);    

            cout << "context new space used: "<< context_new_space_used_ <<"\n";
            cout <<"context pointer space used: " <<context_pointer_space_used_<<"\n";
            cout <<"context data space used: " <<context_data_space_used_<<"\n";
            cout <<"context code space used: " <<context_code_space_used_<<"\n";
            cout <<"context map space used: " <<context_map_space_used_<<"\n";
            cout <<"context cell space used: " <<context_cell_space_used_<<"\n";

            fclose(file);

            //hexdump(context_raw_data_, context_size_);
            cout << "End of constructor "<<"\n";

    }

    Handle<Context> NewContextFromSnapshot() {
    if (context_size_ == 0) {
        return Handle<Context>();
    }
    i::SnapshotByteSource source(context_raw_data_,
                            context_size_);
    i::Deserializer deserializer(&source);
    i::Object* root;
    deserializer.set_reservation(i::NEW_SPACE, context_new_space_used_);
    deserializer.set_reservation(i::OLD_POINTER_SPACE, context_pointer_space_used_);
    deserializer.set_reservation(i::OLD_DATA_SPACE, context_data_space_used_);
    deserializer.set_reservation(i::CODE_SPACE, context_code_space_used_);
    deserializer.set_reservation(i::MAP_SPACE, context_map_space_used_);
    deserializer.set_reservation(i::CELL_SPACE, context_cell_space_used_);
    deserializer.DeserializePartial(&root);
    
    
    if(root->IsHeapObject())
    {
      cout << "Object is a heap object "<<endl;
      i::Map* map = i::HeapObject::cast(root)->map();
      i::Heap* heap = map->GetHeap();


     if(
        map == heap->function_context_map() ||
        map == heap->catch_context_map() ||
        map == heap->with_context_map() ||
        map == heap->native_context_map() ||
        map == heap->block_context_map() ||
        map == heap->module_context_map() ||
        map == heap->global_context_map()
        )
        cout << "Object is a context";

    }
    else
      cout << "Object is not a context";
    

    CHECK(root->IsContext());
    cout << "\n After check for context"<<endl;

    return Handle<Context>(reinterpret_cast<Context*>(i::Context::cast(root)));
    //return Handle<Context>();

    }




};

class ContextifyContext : public ObjectWrap {
public:
    Persistent<Context> context;
    Persistent<Object>  sandbox;
    Persistent<Object>  proxyGlobal;
    int newType;

    static Persistent<FunctionTemplate> jsTmpl;

    ContextifyContext(Local<Object> sbox) {
        NanScope();
        NanAssignPersistent(Object, sandbox, sbox);
    }

    ~ContextifyContext() {
        context.Dispose();
        context.Clear();
        proxyGlobal.Dispose();
        proxyGlobal.Clear();
        sandbox.Dispose();
        sandbox.Clear();
    }

    // We override ObjectWrap::Wrap so that we can create our context after
    // we have a reference to our "host" JavaScript object.  If we try to use
    // handle_ in the ContextifyContext constructor, it will be empty since it's
    // set in ObjectWrap::Wrap.
    inline void Wrap(Handle<Object> handle) {
        ObjectWrap::Wrap(handle);
        getContext();
    }

/*
void Genesis::HookUpInnerGlobal(Handle<i::GlobalObject> inner_global) {
  Handle<i::GlobalObject> inner_global_from_snapshot(
      GlobalObject::cast(native_context_->extension()));
  Handle<i::JSBuiltinsObject> builtins_global(native_context_->builtins());
  native_context_->set_extension(*inner_global);
  native_context_->set_global_object(*inner_global);
  native_context_->set_security_token(*inner_global);
  static const PropertyAttributes attributes =
      static_cast<PropertyAttributes>(READ_ONLY | DONT_DELETE);
  ForceSetProperty(builtins_global,
                   factory()->LookupAsciiSymbol("global"),
                   inner_global,
                   attributes);
  // Set up the reference from the global object to the builtins object.
  JSGlobalObject::cast(*inner_global)->set_builtins(*builtins_global);
  TransferNamedProperties(inner_global_from_snapshot, inner_global);
  TransferIndexedProperties(inner_global_from_snapshot, inner_global);
}
*/
    static void AddToWeakNativeContextList(v8::internal::Context* context) {
  ASSERT(context->IsNativeContext());
  i::Heap* heap = context->GetIsolate()->heap();
#ifdef DEBUG
  { // NOLINT
    ASSERT(context->get(i::Context::NEXT_CONTEXT_LINK)->IsUndefined());
    // Check that context is not in the list yet.
    for (Object* current = heap->native_contexts_list();
         !current->IsUndefined();
         current = i::Context::cast(current)->get(i::Context::NEXT_CONTEXT_LINK)) {
      ASSERT(current != context);
    }
  }
#endif
  context->set(i::Context::NEXT_CONTEXT_LINK, heap->native_contexts_list());
  heap->set_native_contexts_list(context);
}

i::Handle<i::JSGlobalProxy> CreateNewGlobals(
    v8::Handle<v8::ObjectTemplate> global_template,
    Handle<Object> global_object,
    i::Handle<i::GlobalObject>* inner_global_out, i::Isolate *isolate) {
  NanScope();
  // The argument global_template aka data is an ObjectTemplateInfo.
  // It has a constructor pointer that points at global_constructor which is a
  // FunctionTemplateInfo.
  // The global_constructor is used to create or reinitialize the global_proxy.
  // The global_constructor also has a prototype_template pointer that points at
  // js_global_template which is an ObjectTemplateInfo.
  // That in turn has a constructor pointer that points at
  // js_global_constructor which is a FunctionTemplateInfo.
  // js_global_constructor is used to make js_global_function
  // js_global_function is used to make the new inner_global.
  //
  // --- G l o b a l ---
  // Step 1: Create a fresh inner JSGlobalObject.
  i::Handle<i::JSFunction> js_global_function;
  i::Handle<i::ObjectTemplateInfo> js_global_template;
  if (!global_template.IsEmpty()) {
    // Get prototype template of the global_template.
    i::Handle<i::ObjectTemplateInfo> data =
        v8::Utils::OpenHandle(*global_template);
    i::Handle<i::FunctionTemplateInfo> global_constructor =
        i::Handle<i::FunctionTemplateInfo>(
            i::FunctionTemplateInfo::cast(data->constructor()));
    i::Handle<i::Object> proto_template(global_constructor->prototype_template());
    //if (!proto_template->IsUndefined()) {
     // js_global_template =
       //   Handle<i::ObjectTemplateInfo>::cast(proto_template);
    //}
  }

  /*if (js_global_template.is_null()) {
    Handle<String> name = Handle<String>(heap()->empty_symbol());
    Handle<Code> code = Handle<Code>(isolate()->builtins()->builtin(
        Builtins::kIllegal));
    js_global_function =
        factory()->NewFunction(name, JS_GLOBAL_OBJECT_TYPE,
                               JSGlobalObject::kSize, code, true);
    // Change the constructor property of the prototype of the
    // hidden global function to refer to the Object function.
    Handle<i::JSObject> prototype =
        Handle<i::JSObject>(
            JSObject::cast(js_global_function->instance_prototype()));
    CHECK_NOT_EMPTY_HANDLE(isolate(),
                           JSObject::SetLocalPropertyIgnoreAttributes(
                               prototype, factory()->constructor_symbol(),
                               isolate()->object_function(), NONE));
  } else {*/


    i::Handle<i::FunctionTemplateInfo> js_global_constructor(
        i::FunctionTemplateInfo::cast(js_global_template->constructor()));
    js_global_function =
        isolate->factory()->CreateApiFunction(js_global_constructor,
                                     isolate->factory()->InnerGlobalObject);
  //}

  js_global_function->initial_map()->set_is_hidden_prototype();
  js_global_function->initial_map()->set_dictionary_map(true);
  i::Handle<i::GlobalObject> inner_global =
      isolate->factory()->NewGlobalObject(js_global_function);
  if (inner_global_out != NULL) {
    *inner_global_out = inner_global;
  }

  // Step 2: create or re-initialize the global proxy object.
  i::Handle<i::JSFunction> global_proxy_function;
  /*if (global_template.IsEmpty()) {
    Handle<String> name = Handle<String>(heap()->empty_symbol());
    Handle<Code> code = Handle<Code>(isolate()->builtins()->builtin(
        Builtins::kIllegal));
    global_proxy_function =
        factory()->NewFunction(name, JS_GLOBAL_PROXY_TYPE,
                               JSGlobalProxy::kSize, code, true);
  } else {*/
    i::Handle<i::ObjectTemplateInfo> data =
        v8::Utils::OpenHandle(*global_template);
    i::Handle<i::FunctionTemplateInfo> global_constructor(
            i::FunctionTemplateInfo::cast(data->constructor()));
    global_proxy_function =
        isolate->factory()->CreateApiFunction(global_constructor,
                                     isolate->factory()->OuterGlobalObject);
  //}

  //i::Handle<String> global_name = isolate->factory()->LookupAsciiSymbol("global");
  //global_proxy_function->shared()->set_instance_class_name("*global_name");
  global_proxy_function->initial_map()->set_is_access_check_needed(true);

  // Set global_proxy.__proto__ to js_global after ConfigureGlobalObjects
  // Return the global proxy.

  //if (global_object.location() != NULL) {
    ASSERT(global_object->IsJSGlobalProxy());
    //return ReinitializeJSGlobalProxy(
     //   global_proxy_function,
      //  Handle<i::JSGlobalProxy>::cast(global_object));
  //} else {
    return i::Handle<i::JSGlobalProxy>::cast(
        isolate->factory()->NewJSObject(global_proxy_function, i::TENURED));
  //}
}

    void getContext()
    {
      if(newType == 0)
      {
        cout << "regular new context" << endl;
        Local<Context> lcontext = createV8Context();
        NanAssignPersistent(Context, context, lcontext);
        NanAssignPersistent(Object, proxyGlobal, lcontext->Global());
      }
      else
      {
        NanScope();
        cout << "Inside restore context" << endl;
        restoreContextFromSnapshot rCont(1);
        Handle<Context> lcontext = rCont.NewContextFromSnapshot();
        //if (!lcontext.is_null()) {
        cout<<"new methods"<<endl;
        v8::internal::Isolate* isolate = v8::internal::Isolate::Current();
        i::Handle<i::Context> na =
        i::Handle<i::Context>::cast(isolate->global_handles()->Create(reinterpret_cast<i::Object*>(*lcontext)));
    AddToWeakNativeContextList(*na);
    isolate->set_context(*na);
    isolate->counters()->contexts_created_by_snapshot()->Increment();


    Local<FunctionTemplate> ftmpl = FunctionTemplate::New();
        ftmpl->SetHiddenPrototype(true);
        ftmpl->SetClassName(NanPersistentToLocal(sandbox)->GetConstructorName());
        Local<ObjectTemplate> otmpl = ftmpl->InstanceTemplate();
        otmpl->SetNamedPropertyHandler(GlobalPropertyGetter,
                                       GlobalPropertySetter,
                                       GlobalPropertyQuery,
                                       GlobalPropertyDeleter,
                                       GlobalPropertyEnumerator,
                                       createDataWrapper());
        otmpl->SetAccessCheckCallbacks(GlobalPropertyNamedAccessCheck,
                                       GlobalPropertyIndexedAccessCheck);

    Handle<Object>  proxyGlobal1;

    //Handle<ObjectTemplate>otmpl = ObjectTemplate::New();
    i::Handle<i::GlobalObject> inner_global;

    //--------------------------
// Step 1: Create a fresh inner JSGlobalObject.
  i::Handle<i::JSFunction> js_global_function;
  i::Handle<i::ObjectTemplateInfo> js_global_template;
  if (!otmpl.IsEmpty()) {
    // Get prototype template of the global_template.
    i::Handle<i::ObjectTemplateInfo> data =
        v8::Utils::OpenHandle(*otmpl);
    i::Handle<i::FunctionTemplateInfo> global_constructor =
        i::Handle<i::FunctionTemplateInfo>(
            i::FunctionTemplateInfo::cast(data->constructor()));
    i::Handle<i::Object> proto_template(global_constructor->prototype_template());
    //if (!proto_template->IsUndefined()) {
     // js_global_template =
       //   Handle<i::ObjectTemplateInfo>::cast(proto_template);
    //}
  }

  /*if (js_global_template.is_null()) {
    Handle<String> name = Handle<String>(heap()->empty_symbol());
    Handle<Code> code = Handle<Code>(isolate()->builtins()->builtin(
        Builtins::kIllegal));
    js_global_function =
        factory()->NewFunction(name, JS_GLOBAL_OBJECT_TYPE,
                               JSGlobalObject::kSize, code, true);
    // Change the constructor property of the prototype of the
    // hidden global function to refer to the Object function.
    Handle<i::JSObject> prototype =
        Handle<i::JSObject>(
            JSObject::cast(js_global_function->instance_prototype()));
    CHECK_NOT_EMPTY_HANDLE(isolate(),
                           JSObject::SetLocalPropertyIgnoreAttributes(
                               prototype, factory()->constructor_symbol(),
                               isolate()->object_function(), NONE));
  } else {*/


    i::Handle<i::FunctionTemplateInfo> js_global_constructor(
        i::FunctionTemplateInfo::cast(js_global_template->constructor()));
    js_global_function =
        isolate->factory()->CreateApiFunction(js_global_constructor,
                                     isolate->factory()->InnerGlobalObject);
  //}

  js_global_function->initial_map()->set_is_hidden_prototype();
  js_global_function->initial_map()->set_dictionary_map(true);
  inner_global =
      isolate->factory()->NewGlobalObject(js_global_function);
  //if (inner_global != NULL) {
    //*inner_global = inner_global1;
  //}

  // Step 2: create or re-initialize the global proxy object.
  i::Handle<i::JSFunction> global_proxy_function;
  /*if (global_template.IsEmpty()) {
    Handle<String> name = Handle<String>(heap()->empty_symbol());
    Handle<Code> code = Handle<Code>(isolate()->builtins()->builtin(
        Builtins::kIllegal));
    global_proxy_function =
        factory()->NewFunction(name, JS_GLOBAL_PROXY_TYPE,
                               JSGlobalProxy::kSize, code, true);
  } else {*/
    i::Handle<i::ObjectTemplateInfo> data =
        v8::Utils::OpenHandle(*otmpl);
    i::Handle<i::FunctionTemplateInfo> global_constructor(
            i::FunctionTemplateInfo::cast(data->constructor()));
    global_proxy_function =
        isolate->factory()->CreateApiFunction(global_constructor,
                                     isolate->factory()->OuterGlobalObject);
  //}

  //i::Handle<String> global_name = isolate->factory()->LookupAsciiSymbol("global");
  //global_proxy_function->shared()->set_instance_class_name("*global_name");
  global_proxy_function->initial_map()->set_is_access_check_needed(true);

  // Set global_proxy.__proto__ to js_global after ConfigureGlobalObjects
  // Return the global proxy.

  //if (global_object.location() != NULL) {
    ASSERT(proxyGlobal1->IsJSGlobalProxy());
    //return ReinitializeJSGlobalProxy(
     //   global_proxy_function,
      //  Handle<i::JSGlobalProxy>::cast(global_object));
  //} else {
    i::Handle<i::JSGlobalProxy> global_proxy = i::Handle<i::JSGlobalProxy>::cast(
        isolate->factory()->NewJSObject(global_proxy_function, i::TENURED));
    //---------------------------
    
    /*i::Handle<i::JSGlobalProxy> global_proxy =
        CreateNewGlobals(otmpl,
                         proxyGlobal1,
                         &inner_global, isolate);
*/
    //HookUpGlobalProxy(inner_global, global_proxy);
        // Set the native context for the global object.
  inner_global->set_native_context(*na);
  inner_global->set_global_context(*na);
  inner_global->set_global_receiver(*global_proxy);
  global_proxy->set_native_context(*na);
  na->set_global_proxy(*global_proxy);

    //HookUpInnerGlobal(inner_global);

    //if (!ConfigureGlobalObjects(global_template)) return;
  //}
        NanAssignPersistent(Context, context, lcontext);
        NanAssignPersistent(Object, proxyGlobal, lcontext->Global());
      }
      

    }

    // This is an object that just keeps an internal pointer to this
    // ContextifyContext.  It's passed to the NamedPropertyHandler.  If we
    // pass the main JavaScript context object we're embedded in, then the
    // NamedPropertyHandler will store a reference to it forever and keep it
    // from getting gc'd.
    Local<Object> createDataWrapper () {
        NanScope();
        Local<Object> wrapper = NanPersistentToLocal(dataWrapperCtor)->NewInstance();
        NanSetInternalFieldPointer(wrapper, 0, this);
        return scope.Close(wrapper);
    }

    inline Local<Context> createV8Context() {
        Local<FunctionTemplate> ftmpl = FunctionTemplate::New();
        ftmpl->SetHiddenPrototype(true);
        ftmpl->SetClassName(NanPersistentToLocal(sandbox)->GetConstructorName());
        Local<ObjectTemplate> otmpl = ftmpl->InstanceTemplate();
        otmpl->SetNamedPropertyHandler(GlobalPropertyGetter,
                                       GlobalPropertySetter,
                                       GlobalPropertyQuery,
                                       GlobalPropertyDeleter,
                                       GlobalPropertyEnumerator,
                                       createDataWrapper());
        otmpl->SetAccessCheckCallbacks(GlobalPropertyNamedAccessCheck,
                                       GlobalPropertyIndexedAccessCheck);
        return NanNewContextHandle(NULL, otmpl);
    }

    static void Init(Handle<Object> target) {
        NanScope();
        Local<FunctionTemplate> tmpl = NanNewLocal<FunctionTemplate>(FunctionTemplate::New());
        tmpl->InstanceTemplate()->SetInternalFieldCount(1);
        NanAssignPersistent(FunctionTemplate, dataWrapperTmpl, tmpl);
        NanAssignPersistent(Function, dataWrapperCtor, tmpl->GetFunction());

        Local<FunctionTemplate> ljsTmpl = NanNewLocal<FunctionTemplate>(FunctionTemplate::New(New));
        ljsTmpl->InstanceTemplate()->SetInternalFieldCount(1);
        ljsTmpl->SetClassName(String::NewSymbol("ContextifyContext"));
        NODE_SET_PROTOTYPE_METHOD(ljsTmpl, "run",       ContextifyContext::Run);
        NODE_SET_PROTOTYPE_METHOD(ljsTmpl, "getGlobal", ContextifyContext::GetGlobal);
        NODE_SET_PROTOTYPE_METHOD(ljsTmpl, "save",       ContextifyContext::Save);

        NanAssignPersistent(FunctionTemplate, jsTmpl, ljsTmpl);
        target->Set(String::NewSymbol("ContextifyContext"), ljsTmpl->GetFunction());
    }

    static NAN_METHOD(New) {
        NanScope();

        if (args.Length() >2) {
            Local<String> msg = String::New("Wrong number of arguments passed to ContextifyContext constructor");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }

        if (!(args[0]->IsObject()) && args.Length() == 1) {
            Local<String> msg = String::New("Argument to ContextifyContext constructor must be an object.");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }

        ContextifyContext* ctx = new ContextifyContext(args[0]->ToObject());
        if(args.Length() == 1)
        {
            //ContextifyContext* ctx = new ContextifyContext(args[0]->ToObject());
            //ctx->c = ctx->createV8Context();
            ctx->newType = 0;
            ctx->Wrap(args.This());
            NanReturnValue(args.This());
        }
        else // restore context from snapshot
        {
            ctx->newType = 1;
            
            //ctx->c = lcontext;
            ctx->Wrap(args.This());
            NanReturnValue(args.This());

        }
    }

    static NAN_METHOD(Run) {
        NanScope();
        if (args.Length() == 0) {
            Local<String> msg = String::New("Must supply at least 1 argument to run");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }
        if (!args[0]->IsString()) {
            Local<String> msg = String::New("First argument to run must be a String.");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(args.This());
        Persistent<Context> context;
        Local<Context> lcontext = NanPersistentToLocal(ctx->context);
        NanAssignPersistent(Context, context, lcontext);
        lcontext->Enter();
        Local<String> code = args[0]->ToString();

        TryCatch trycatch;
        Handle<Script> script;

        if (args.Length() > 1 && args[1]->IsString()) {
            script = Script::Compile(code, args[1]->ToString());
        } else {
            script = Script::Compile(code);
        }

        if (script.IsEmpty()) {
          lcontext->Exit();
          NanReturnValue(trycatch.ReThrow());
        }

        Handle<Value> result = script->Run();
        lcontext->Exit();

        if (result.IsEmpty()) {
            NanReturnValue(trycatch.ReThrow());
        }

        NanReturnValue(result);
    }

    static NAN_METHOD(Save) {
        i::Serializer::Enable();

        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(args.This());
        Persistent<Context> context = ctx->context;
        //Local<Context> lcontext = NanPersistentToLocal(ctx->context);
        //NanAssignPersistent(Context, context, lcontext);

        context->Enter();
        
        V8::SetCaptureStackTraceForUncaughtExceptions(true, 100);

    {
      HandleScope scope;
    
        if (args.Length() == 0) {
            Local<String> msg = String::New("Must supply at least 1 argument to save context");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }
        if (!args[0]->IsString()) {
            Local<String> msg = String::New("First argument to save must be a String.");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }
        /*
        BZip2Decompressor natives_decompressor;
        int bz2_result = natives_decompressor.Decompress();
        if (bz2_result != BZ_OK) {
            fprintf(stderr, "bzip error code: %d\n", bz2_result);
            exit(1);
        }
        */
        
        


        context->Exit();
    } 


        // If we don't do this then we end up with a stray root pointing at the
        // context even after we have disposed of the context.
        HEAP->CollectAllGarbage(i::Heap::kNoGCFlags, "contextify");
  
        while(!V8::IdleNotification()) {};
        i::Object* raw_context = *(v8::Utils::OpenHandle(*context));

        context.Dispose();
        //Local<String> fileName = args[0]->ToString();
        myByteSink sink("myBinarySnap");

        //while(!V8::IdleNotification()) {};

  
        // This results in a somewhat smaller snapshot, probably because it gets rid
        // of some things that are cached between garbage collections.
        i::StartupSerializer ser(&sink);
        ser.SerializeStrongReferences();

        i::PartialSerializer partial_ser(&ser, sink.partial_sink());
        partial_ser.Serialize(&raw_context);

        ser.SerializeWeakReferences();
  
  /*
        BZip2Compressor compressor;
        if (!sink.Compress(&compressor))
            printf("Cannot compress");
        if (!sink.partial_sink()->Compress(&compressor))
            printf("Cannot compress partial sink");
*/
        sink.WritePartialSnapshot();

  
        sink.WriteSpaceUsed(
        "context_",
        partial_ser.CurrentAllocationAddress(i::NEW_SPACE),
        partial_ser.CurrentAllocationAddress(i::OLD_POINTER_SPACE),
        partial_ser.CurrentAllocationAddress(i::OLD_DATA_SPACE),
        partial_ser.CurrentAllocationAddress(i::CODE_SPACE),
        partial_ser.CurrentAllocationAddress(i::MAP_SPACE),
        partial_ser.CurrentAllocationAddress(i::CELL_SPACE));
        /*
        sink.WriteSpaceUsed(
        "",
        ser.CurrentAllocationAddress(i::NEW_SPACE),
        ser.CurrentAllocationAddress(i::OLD_POINTER_SPACE),
        ser.CurrentAllocationAddress(i::OLD_DATA_SPACE),
        ser.CurrentAllocationAddress(i::CODE_SPACE),
        ser.CurrentAllocationAddress(i::MAP_SPACE),
        ser.CurrentAllocationAddress(i::CELL_SPACE));
*/
    }

    static bool InstanceOf(Handle<Value> value) {
      return NanHasInstance(jsTmpl, value);
    }

    static NAN_METHOD(GetGlobal) {
        NanScope();
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(args.This());
        NanReturnValue(ctx->proxyGlobal);
    }

    static bool GlobalPropertyNamedAccessCheck(Local<Object> host,
                                               Local<Value>  key,
                                               AccessType    type,
                                               Local<Value>  data) {
        return true;
    }

    static bool GlobalPropertyIndexedAccessCheck(Local<Object> host,
                                                 uint32_t      key,
                                                 AccessType    type,
                                                 Local<Value>  data) {
        return true;
    }

    static NAN_PROPERTY_GETTER(GlobalPropertyGetter) {
        NanScope();
        Local<Object> data = args.Data()->ToObject();
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(data);
        Local<Value> rv = NanPersistentToLocal(ctx->sandbox)->GetRealNamedProperty(property);
        if (rv.IsEmpty()) {
            rv = NanPersistentToLocal(ctx->proxyGlobal)->GetRealNamedProperty(property);
        }
        NanReturnValue(rv);
    }

    static NAN_PROPERTY_SETTER(GlobalPropertySetter) {
        NanScope();
        Local<Object> data = args.Data()->ToObject();
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(data);
        NanPersistentToLocal(ctx->sandbox)->Set(property, value);
        NanReturnValue(value);
    }

    static NAN_PROPERTY_QUERY(GlobalPropertyQuery) {
        NanScope();
        Local<Object> data = args.Data()->ToObject();
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(data);
        if (!NanPersistentToLocal(ctx->sandbox)->GetRealNamedProperty(property).IsEmpty() ||
            !NanPersistentToLocal(ctx->proxyGlobal)->GetRealNamedProperty(property).IsEmpty()) {
            NanReturnValue(Integer::New(None));
         } else {
            NanReturnValue(Handle<Integer>());
         }
    }

    static NAN_PROPERTY_DELETER(GlobalPropertyDeleter) {
        NanScope();
        Local<Object> data = args.Data()->ToObject();
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(data);
        bool success = NanPersistentToLocal(ctx->sandbox)->Delete(property);
        NanReturnValue(Boolean::New(success));
    }

    static NAN_PROPERTY_ENUMERATOR(GlobalPropertyEnumerator) {
        NanScope();
        Local<Object> data = args.Data()->ToObject();
        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(data);
        NanReturnValue(NanPersistentToLocal(ctx->sandbox)->GetPropertyNames());
    }
};

class ContextifyScript : public ObjectWrap {
public:
    static Persistent<FunctionTemplate> scriptTmpl;
    Persistent<Script> script;

    static void Init(Handle<Object> target) {
        NanScope();
        Local<FunctionTemplate> lscriptTmpl = NanNewLocal<FunctionTemplate>(FunctionTemplate::New(New));
        lscriptTmpl->InstanceTemplate()->SetInternalFieldCount(1);
        lscriptTmpl->SetClassName(String::NewSymbol("ContextifyScript"));

        NODE_SET_PROTOTYPE_METHOD(lscriptTmpl, "runInContext", RunInContext);

        NanAssignPersistent(FunctionTemplate, scriptTmpl, lscriptTmpl);
        target->Set(String::NewSymbol("ContextifyScript"),
                    lscriptTmpl->GetFunction());
    }
    static NAN_METHOD(New) {
        NanScope();
        ContextifyScript *contextify_script = new ContextifyScript();
        contextify_script->Wrap(args.Holder());

        if (args.Length() < 1) {
          NanReturnValue(ThrowException(Exception::TypeError(
            String::New("needs at least 'code' argument."))));
        }

        Local<String> code = args[0]->ToString();
        Local<String> filename = args.Length() > 1
                               ? args[1]->ToString()
                               : String::New("ContextifyScript.<anonymous>");

        Handle<Context> context = Context::GetCurrent();
        Context::Scope context_scope(context);

        // Catch errors
        TryCatch trycatch;

        Handle<Script> v8_script = Script::New(code, filename);

        if (v8_script.IsEmpty()) {
          NanReturnValue(trycatch.ReThrow());
        }

        NanAssignPersistent(Script, contextify_script->script, v8_script);

        NanReturnValue(args.This());
    }

    static NAN_METHOD(RunInContext) {
        NanScope();
        if (args.Length() == 0) {
            Local<String> msg = String::New("Must supply at least 1 argument to runInContext");
            NanReturnValue(ThrowException(Exception::Error(msg)));
        }
        if (!ContextifyContext::InstanceOf(args[0]->ToObject())) {
            Local<String> msg = String::New("First argument must be a ContextifyContext.");
            NanReturnValue(ThrowException(Exception::TypeError(msg)));
        }

        ContextifyContext* ctx = ObjectWrap::Unwrap<ContextifyContext>(args[0]->ToObject());
        Local<Context> lcontext = NanPersistentToLocal(ctx->context);
        Persistent<Context> context;
        NanAssignPersistent(Context, context, lcontext);
        lcontext->Enter();
        ContextifyScript* wrapped_script = ObjectWrap::Unwrap<ContextifyScript>(args.This());
        Handle<Script> script = NanPersistentToLocal(wrapped_script->script);
        TryCatch trycatch;
        if (script.IsEmpty()) {
          lcontext->Exit();
          NanReturnValue(trycatch.ReThrow());
        }
        Handle<Value> result = script->Run();
        lcontext->Exit();
        if (result.IsEmpty()) {
            NanReturnValue(trycatch.ReThrow());
        }
        NanReturnValue(result);
    }

    ~ContextifyScript() {
        script.Dispose();
    }
};

Persistent<FunctionTemplate> ContextifyContext::jsTmpl;
Persistent<FunctionTemplate> ContextifyScript::scriptTmpl;

extern "C" {
    static void init(Handle<Object> target) {
        ContextifyContext::Init(target);
        ContextifyScript::Init(target);
    }
    NODE_MODULE(contextify, init);
};
